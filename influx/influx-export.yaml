apiVersion: influxdata.com/v2alpha1
kind: Label
metadata:
    name: affectionate-payne-baf00d
spec:
    color: '#108174'
    name: outputs.influxdb_v2
---
apiVersion: influxdata.com/v2alpha1
kind: Label
metadata:
    name: angry-boyd-baf00f
spec:
    color: '#326BBA'
    name: x509
---
apiVersion: influxdata.com/v2alpha1
kind: Label
metadata:
    name: elastic-pike-baf009
spec:
    color: '#00a3ff'
    name: inputs.kubernetes
---
apiVersion: influxdata.com/v2alpha1
kind: Label
metadata:
    name: kind-gould-baf00b
spec:
    color: '#326BBA'
    name: inputs.win_perf_counters
---
apiVersion: influxdata.com/v2alpha1
kind: Label
metadata:
    name: lucid-tereshkova-baf003
spec:
    color: '#7A65F2'
    name: Windows System Template
---
apiVersion: influxdata.com/v2alpha1
kind: Label
metadata:
    name: nice-sammet-baf005
spec:
    color: '#BF3D5E'
    name: haproxy
---
apiVersion: influxdata.com/v2alpha1
kind: Label
metadata:
    name: tender-johnson-baf007
spec:
    color: '#066fc5'
    name: inputs.kube_inventory
---
apiVersion: influxdata.com/v2alpha1
kind: Label
metadata:
    name: xenodochial-pascal-baf001
spec:
    color: '#757888'
    name: K8S
---
apiVersion: influxdata.com/v2alpha1
kind: Bucket
metadata:
    name: adoring-wozniak-baf015
spec:
    name: telegraf
    retentionRules:
        - everySeconds: 2.592e+06
          type: expire
---
apiVersion: influxdata.com/v2alpha1
kind: Bucket
metadata:
    name: affectionate-williams-faf003
spec:
    name: telegraf-sidecar
    retentionRules:
        - everySeconds: 2.592e+06
          type: expire
---
apiVersion: influxdata.com/v2alpha1
kind: Bucket
metadata:
    name: crumbling-greider-baf017
spec:
    name: telegraf-dev
    retentionRules:
        - everySeconds: 21600
          type: expire
---
apiVersion: influxdata.com/v2alpha1
kind: Bucket
metadata:
    name: eerie-almeida-faf001
spec:
    name: telegraf-kubernetes
    retentionRules:
        - everySeconds: 1.2096e+06
          type: expire
---
apiVersion: influxdata.com/v2alpha1
kind: Bucket
metadata:
    name: great-lewin-baf013
spec:
    associations:
        - kind: Label
          name: nice-sammet-baf005
    name: haproxy
    retentionRules:
        - everySeconds: 2.592e+06
          type: expire
---
apiVersion: influxdata.com/v2alpha1
kind: Bucket
metadata:
    name: inspiring-mayer-faf005
spec:
    name: uptime
    retentionRules:
        - everySeconds: 7.776e+06
          type: expire
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: bettering-carver-faf004
spec:
    every: 5m
    name: dev2
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://dev2.vcare.pl/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: bold-payne-3af005
spec:
    every: 5m
    name: fs1-rjl
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://fs1-rjl.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: compassionate-satoshi-faf002
spec:
    every: 5m
    name: gpc-dev2
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://gpc-dev2.vcare.pl/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: cranky-germain-baf001
spec:
    every: 5m
    name: rjl
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://dalarna.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: crazy-tesla-3af009
spec:
    every: 5m
    name: embassy-no
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://embassy-no.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: dangling-noyce-7af001
spec:
    every: 5m
    name: fs1-nl
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://fs1-nl.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: dreamy-golick-baf007
spec:
    every: 5m
    name: fs1-gb
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://fs1-gb.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: eager-feynman-3af001
spec:
    every: 5m
    name: nl
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://nl.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: elegant-wu-faf009
spec:
    every: 5m
    name: fi
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://fi.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: endangered-keller-3af00b
spec:
    every: 5m
    name: gb
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://gb.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: endangered-robinson-7af005
spec:
    every: 5m
    name: fs1-fi
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://fs1-fi.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: gifted-chebyshev-7af007
spec:
    every: 5m
    name: embassy-se
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://embassy-se.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: gifted-hoover-baf005
spec:
    every: 5m
    name: fs1-dalarna
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://fs1-dalarna.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: great-johnson-faf007
spec:
    every: 5m
    name: fs1-se
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://fs1-se.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: hardcore-lichterman-faf00d
spec:
    every: 5m
    name: embassy-rjl
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://embassy-rjl.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: hardcore-williams-baf003
spec:
    every: 5m
    name: vgr
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://mittvardmote.vgregion.se/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: jolly-volhard-3af007
spec:
    every: 5m
    name: dalarna
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://dalarna.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: keen-tu-faf006
spec:
    every: 5m
    name: embassy-nl
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://embassy-nl.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: nifty-lovelace-3af003
spec:
    every: 5m
    name: "no"
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://no.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: noshing-greider-7af009
spec:
    every: 5m
    name: se
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://se.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: quizzical-moore-faf000
spec:
    every: 5m
    name: fs1-no
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://fs1-no.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: spectacular-swirles-faf00b
spec:
    every: 5m
    name: embassy-gb
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://embassy-gb.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: xenodochial-germain-7af003
spec:
    every: 5m
    name: embassy-fi
    query: |-
        import "strings"
        import "csv"
        import "experimental/http"
        import "system"

        option v = {bucket: "telegraf"}


        theURLtoMonitor = "https://embassy-fi.visibacare.com/health/up"
        timeBeforeCall = system.time()
        response = http.get(url: theURLtoMonitor)
        timeAfterCall = system.time()
        data = "#group,false,false,true,true
        #datatype,string,long,string,string
        #default,mean,,,
        ,result,table,service,response_code
        ,,0,http_ping,${string(v: response.statusCode)}"

        csv.from(csv: data)
        	|> map(fn: (r) =>
        		({r with _time: now()}))
        	|> map(fn: (r) =>
        		({r with _measurement: "ResponseCode", url: theURLtoMonitor, method: "GET"}))
        	|> to(bucket: "uptime", org: "Visiba", fieldFn: (r) =>
        		({"response_code": uint(v: response.statusCode)}))
---
apiVersion: influxdata.com/v2alpha1
kind: Variable
metadata:
    name: crazy-mahavira-faf00a
spec:
    associations:
        - kind: Label
          name: lucid-tereshkova-baf003
    language: flux
    name: bucket
    query: |-
        buckets()
          |> rename(columns: {"name": "_value"})
          |> keep(columns: ["_value"])
    type: query
---
apiVersion: influxdata.com/v2alpha1
kind: Variable
metadata:
    name: objective-bhaskara-faf00e
spec:
    associations:
        - kind: Label
          name: lucid-tereshkova-baf003
    language: flux
    name: windows_host
    query: |-
        import "influxdata/influxdb/v1"
        v1.measurementTagValues(bucket: v.bucket, measurement: "win_system", tag: "host")
    type: query
---
apiVersion: influxdata.com/v2alpha1
kind: Dashboard
metadata:
    name: amusing-poitras-faf001
spec:
    charts:
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: This dashboard gives you an overview of System metrics with metrics from `system`, `mem`, `diskio`, `swap` and `net` measurements. See the [Telegraf Documentation](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/system) for help configuring these plugins.
          width: 12
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          height: 1
          kind: Single_Stat
          name: System Uptime
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "uptime")
                   |> last()
                   |> map(fn: (r) => ({r with _value: r._value / 86400}))
                  |> yield(name: "last")
          suffix: ' days'
          width: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "disk")
                  |> filter(fn: (r) => r._field == "used_percent")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk IO
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "diskio")
                  |> filter(fn: (r) => r._field == "read_bytes" or r._field == "write_bytes")
                  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 3
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: nCPUs
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "n_cpus")
                  |> last()
                  |> yield(name: "last")
          suffix: ' cpus'
          width: 2
          xPos: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: CPU Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "cpu")
                  |> filter(fn: (r) => r._field == "usage_user" or r._field == "usage_system" or r._field == "usage_idle")
                  |> filter(fn: (r) => r.cpu == "cpu-total")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Network
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "net")
                  |> filter(fn: (r) => r._field == "bytes_recv" or r._field == "bytes_sent")
                  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 3
          xPos: 3
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "load1")
                 |> last()
                  |> yield(name: "mean")
          width: 2
          xPos: 5
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              label: Load
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "load1" or r._field == "load5" or r._field == "load15")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 6
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Processes
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "processes")
                  |> filter(fn: (r) => r._field == "running" or r._field == "blocked" or r._field == "idle" or r._field == "unknown")
                  |> aggregateWindow(every: v.windowPeriod, fn: max)
                  |> yield(name: "max")
          width: 3
          xPos: 6
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Total Memory
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "mem")
                  |> filter(fn: (r) => r._field == "total")
                  |> last()
                  |> map(fn: (r) => ({r with _value: float(v: r._value) / 1024.0 / 1024.0 / 1024.0}))
                  |> yield(name: "last")
          suffix: ' GB'
          width: 2
          xPos: 7
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
            - hex: '#8F8AF4'
              id: c2f922df-60a1-4471-91fc-c16427e7fcfb
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#A51414'
              id: 330f7fee-d44e-4a15-b2d6-2330178ec203
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#F4CF31'
              id: e3c73eb3-665a-414b-afdd-1686c9b962d9
              name: Do Androids Dream of Electric Sheep?
              type: scale
          decimalPlaces: 1
          height: 4
          kind: Single_Stat_Plus_Line
          name: Memory Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "mem")
                  |> filter(fn: (r) => r._field == "used_percent")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          suffix: '%'
          width: 3
          xPos: 9
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Swap
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "swap")
                  |> filter(fn: (r) => r._field == "total" or r._field == "used")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 9
          yPos: 5
    description: A collection of useful visualizations for monitoring your system stats
    name: System
---
apiVersion: influxdata.com/v2alpha1
kind: Dashboard
metadata:
    name: crazy-williamson-3af001
spec:
    charts:
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: This dashboard gives you an overview of System metrics with metrics from `system`, `mem`, `diskio`, `swap` and `net` measurements. See the [Telegraf Documentation](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/system) for help configuring these plugins.
          width: 12
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          height: 1
          kind: Single_Stat
          name: System Uptime
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "uptime")
                   |> last()
                   |> map(fn: (r) => ({r with _value: r._value / 86400}))
                  |> yield(name: "last")
          suffix: ' days'
          width: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "disk")
                  |> filter(fn: (r) => r._field == "used_percent")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk IO
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "diskio")
                  |> filter(fn: (r) => r._field == "read_bytes" or r._field == "write_bytes")
                  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 3
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: nCPUs
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "n_cpus")
                  |> last()
                  |> yield(name: "last")
          suffix: ' cpus'
          width: 2
          xPos: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: CPU Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "cpu")
                  |> filter(fn: (r) => r._field == "usage_user" or r._field == "usage_system" or r._field == "usage_idle")
                  |> filter(fn: (r) => r.cpu == "cpu-total")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Network
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "net")
                  |> filter(fn: (r) => r._field == "bytes_recv" or r._field == "bytes_sent")
                  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 3
          xPos: 3
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "load1")
                 |> last()
                  |> yield(name: "mean")
          width: 2
          xPos: 5
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              label: Load
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "load1" or r._field == "load5" or r._field == "load15")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 6
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Processes
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "processes")
                  |> filter(fn: (r) => r._field == "running" or r._field == "blocked" or r._field == "idle" or r._field == "unknown")
                  |> aggregateWindow(every: v.windowPeriod, fn: max)
                  |> yield(name: "max")
          width: 3
          xPos: 6
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Total Memory
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "mem")
                  |> filter(fn: (r) => r._field == "total")
                  |> last()
                  |> map(fn: (r) => ({r with _value: float(v: r._value) / 1024.0 / 1024.0 / 1024.0}))
                  |> yield(name: "last")
          suffix: ' GB'
          width: 2
          xPos: 7
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
            - hex: '#8F8AF4'
              id: c2f922df-60a1-4471-91fc-c16427e7fcfb
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#A51414'
              id: 330f7fee-d44e-4a15-b2d6-2330178ec203
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#F4CF31'
              id: e3c73eb3-665a-414b-afdd-1686c9b962d9
              name: Do Androids Dream of Electric Sheep?
              type: scale
          decimalPlaces: 1
          height: 4
          kind: Single_Stat_Plus_Line
          name: Memory Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "mem")
                  |> filter(fn: (r) => r._field == "used_percent")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          suffix: '%'
          width: 3
          xPos: 9
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Swap
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "swap")
                  |> filter(fn: (r) => r._field == "total" or r._field == "used")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 9
          yPos: 5
    description: A collection of useful visualizations for monitoring your system stats
    name: System
---
apiVersion: influxdata.com/v2alpha1
kind: Dashboard
metadata:
    name: earnest-thompson-faf001
spec:
    charts:
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: This dashboard gives you an overview of System metrics with metrics from `system`, `mem`, `diskio`, `swap` and `net` measurements. See the [Telegraf Documentation](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/system) for help configuring these plugins.
          width: 12
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          height: 1
          kind: Single_Stat
          name: System Uptime
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "uptime")
                   |> last()
                   |> map(fn: (r) => ({r with _value: r._value / 86400}))
                  |> yield(name: "last")
          suffix: ' days'
          width: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "disk")
                  |> filter(fn: (r) => r._field == "used_percent")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk IO
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "diskio")
                  |> filter(fn: (r) => r._field == "read_bytes" or r._field == "write_bytes")
                  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 3
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: nCPUs
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "n_cpus")
                  |> last()
                  |> yield(name: "last")
          suffix: ' cpus'
          width: 2
          xPos: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: CPU Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "cpu")
                  |> filter(fn: (r) => r._field == "usage_user" or r._field == "usage_system" or r._field == "usage_idle")
                  |> filter(fn: (r) => r.cpu == "cpu-total")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Network
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "net")
                  |> filter(fn: (r) => r._field == "bytes_recv" or r._field == "bytes_sent")
                  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 3
          xPos: 3
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "load1")
                 |> last()
                  |> yield(name: "mean")
          width: 2
          xPos: 5
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              label: Load
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "load1" or r._field == "load5" or r._field == "load15")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 6
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Processes
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "processes")
                  |> filter(fn: (r) => r._field == "running" or r._field == "blocked" or r._field == "idle" or r._field == "unknown")
                  |> aggregateWindow(every: v.windowPeriod, fn: max)
                  |> yield(name: "max")
          width: 3
          xPos: 6
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Total Memory
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "mem")
                  |> filter(fn: (r) => r._field == "total")
                  |> last()
                  |> map(fn: (r) => ({r with _value: float(v: r._value) / 1024.0 / 1024.0 / 1024.0}))
                  |> yield(name: "last")
          suffix: ' GB'
          width: 2
          xPos: 7
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
            - hex: '#8F8AF4'
              id: c2f922df-60a1-4471-91fc-c16427e7fcfb
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#A51414'
              id: 330f7fee-d44e-4a15-b2d6-2330178ec203
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#F4CF31'
              id: e3c73eb3-665a-414b-afdd-1686c9b962d9
              name: Do Androids Dream of Electric Sheep?
              type: scale
          decimalPlaces: 1
          height: 4
          kind: Single_Stat_Plus_Line
          name: Memory Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "mem")
                  |> filter(fn: (r) => r._field == "used_percent")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          suffix: '%'
          width: 3
          xPos: 9
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Swap
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "swap")
                  |> filter(fn: (r) => r._field == "total" or r._field == "used")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 9
          yPos: 5
    description: A collection of useful visualizations for monitoring your system stats
    name: System
---
apiVersion: influxdata.com/v2alpha1
kind: Dashboard
metadata:
    name: eerie-visvesvaraya-faf001
spec:
    charts:
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: This dashboard gives you an overview of System metrics with metrics from `system`, `mem`, `diskio`, `swap` and `net` measurements. See the [Telegraf Documentation](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/system) for help configuring these plugins.
          width: 12
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          height: 1
          kind: Single_Stat
          name: System Uptime
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "uptime")
                   |> last()
                   |> map(fn: (r) => ({r with _value: r._value / 86400}))
                  |> yield(name: "last")
          suffix: ' days'
          width: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "disk")
                  |> filter(fn: (r) => r._field == "used_percent")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk IO
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "diskio")
                  |> filter(fn: (r) => r._field == "read_bytes" or r._field == "write_bytes")
                  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 3
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: nCPUs
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "n_cpus")
                  |> last()
                  |> yield(name: "last")
          suffix: ' cpus'
          width: 2
          xPos: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: CPU Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "cpu")
                  |> filter(fn: (r) => r._field == "usage_user" or r._field == "usage_system" or r._field == "usage_idle")
                  |> filter(fn: (r) => r.cpu == "cpu-total")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Network
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "net")
                  |> filter(fn: (r) => r._field == "bytes_recv" or r._field == "bytes_sent")
                  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 3
          xPos: 3
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "load1")
                 |> last()
                  |> yield(name: "mean")
          width: 2
          xPos: 5
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              label: Load
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "load1" or r._field == "load5" or r._field == "load15")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 6
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Processes
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "processes")
                  |> filter(fn: (r) => r._field == "running" or r._field == "blocked" or r._field == "idle" or r._field == "unknown")
                  |> aggregateWindow(every: v.windowPeriod, fn: max)
                  |> yield(name: "max")
          width: 3
          xPos: 6
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Total Memory
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "mem")
                  |> filter(fn: (r) => r._field == "total")
                  |> last()
                  |> map(fn: (r) => ({r with _value: float(v: r._value) / 1024.0 / 1024.0 / 1024.0}))
                  |> yield(name: "last")
          suffix: ' GB'
          width: 2
          xPos: 7
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
            - hex: '#8F8AF4'
              id: c2f922df-60a1-4471-91fc-c16427e7fcfb
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#A51414'
              id: 330f7fee-d44e-4a15-b2d6-2330178ec203
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#F4CF31'
              id: e3c73eb3-665a-414b-afdd-1686c9b962d9
              name: Do Androids Dream of Electric Sheep?
              type: scale
          decimalPlaces: 1
          height: 4
          kind: Single_Stat_Plus_Line
          name: Memory Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "mem")
                  |> filter(fn: (r) => r._field == "used_percent")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          suffix: '%'
          width: 3
          xPos: 9
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Swap
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "swap")
                  |> filter(fn: (r) => r._field == "total" or r._field == "used")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 9
          yPos: 5
    description: A collection of useful visualizations for monitoring your system stats
    name: System
---
apiVersion: influxdata.com/v2alpha1
kind: Dashboard
metadata:
    name: elated-rosalind-faf001
spec:
    associations:
        - kind: Label
          name: angry-boyd-baf00f
    charts:
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
          decimalPlaces: 2
          height: 6
          kind: Single_Stat
          name: Number of Certificates
          queries:
            - query: |-
                from(bucket: "x509")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "x509_cert")
                  |> filter(fn: (r) => r["_field"] == "expiry")
                  |> count()
                  |> yield(name: "count")
          width: 2
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
            - hex: '#BF3D5E'
              name: ruby
              type: text
            - hex: '#4ED8A0'
              name: rainforest
              type: text
              value: 15
          height: 3
          kind: Single_Stat
          name: cduser.com - Expire in
          queries:
            - query: |-
                from(bucket: "x509")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "x509_cert")
                  |> filter(fn: (r) => r["_field"] == "expiry")
                  |> filter(fn: (r) => r["common_name"] == "cduser.com")
                  |> last()
                  |> map(fn: (r) => ({r with _value: r._value / 86400}))
          suffix: ' days'
          width: 2
          xPos: 2
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
            - hex: '#BF3D5E'
              name: ruby
              type: text
            - hex: '#4ED8A0'
              name: rainforest
              type: text
              value: 15
          height: 3
          kind: Single_Stat
          name: influxdata.com - Expire in
          queries:
            - query: |-
                from(bucket: "x509")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "x509_cert")
                  |> filter(fn: (r) => r["_field"] == "expiry")
                  |> filter(fn: (r) => r["common_name"] == "influxdata.com")
                  |> last()
                  |> map(fn: (r) => ({r with _value: r._value / 86400}))
          suffix: ' days'
          width: 2
          xPos: 4
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
            - hex: '#BF3D5E'
              name: ruby
              type: text
            - hex: '#4ED8A0'
              name: rainforest
              type: text
              value: 15
          height: 3
          kind: Single_Stat
          name: stats.cduser.com - Expire in
          queries:
            - query: |-
                from(bucket: "x509")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "x509_cert")
                  |> filter(fn: (r) => r["_field"] == "expiry")
                  |> filter(fn: (r) => r["common_name"] == "stats.cduser.com")
                  |> last()
                  |> map(fn: (r) => ({r with _value: r._value / 86400}))
          suffix: ' days'
          width: 2
          xPos: 6
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
            - hex: '#BF3D5E'
              name: ruby
              type: text
            - hex: '#4ED8A0'
              name: rainforest
              type: text
              value: 15
          height: 3
          kind: Single_Stat
          name: twitter.com - Expire in
          queries:
            - query: |-
                from(bucket: "x509")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "x509_cert")
                  |> filter(fn: (r) => r["_field"] == "expiry")
                  |> filter(fn: (r) => r["common_name"] == "twitter.com")
                  |> last()
                  |> map(fn: (r) => ({r with _value: r._value / 86400}))
          suffix: ' days'
          width: 2
          xPos: 8
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
            - hex: '#BF3D5E'
              name: ruby
              type: text
            - hex: '#4ED8A0'
              name: rainforest
              type: text
              value: 15
          height: 3
          kind: Single_Stat
          name: google.com - Expire in
          queries:
            - query: |-
                from(bucket: "x509")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "x509_cert")
                  |> filter(fn: (r) => r["_field"] == "expiry")
                  |> filter(fn: (r) => r["common_name"] == "www.google.com")
                  |> last()
                  |> map(fn: (r) => ({r with _value: r._value / 86400}))
          suffix: ' days'
          width: 2
          xPos: 10
    name: x509 - SSL Expiration Monitor
---
apiVersion: influxdata.com/v2alpha1
kind: Dashboard
metadata:
    name: focused-kapitsa-faf001
spec:
    charts:
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: This dashboard gives you an overview of System metrics with metrics from `system`, `mem`, `diskio`, `swap` and `net` measurements. See the [Telegraf Documentation](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/system) for help configuring these plugins.
          width: 12
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          height: 1
          kind: Single_Stat
          name: System Uptime
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "uptime")
                   |> last()
                   |> map(fn: (r) => ({r with _value: r._value / 86400}))
                  |> yield(name: "last")
          suffix: ' days'
          width: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "disk")
                  |> filter(fn: (r) => r._field == "used_percent")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk IO
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "diskio")
                  |> filter(fn: (r) => r._field == "read_bytes" or r._field == "write_bytes")
                  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 3
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: nCPUs
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "n_cpus")
                  |> last()
                  |> yield(name: "last")
          suffix: ' cpus'
          width: 2
          xPos: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: CPU Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "cpu")
                  |> filter(fn: (r) => r._field == "usage_user" or r._field == "usage_system" or r._field == "usage_idle")
                  |> filter(fn: (r) => r.cpu == "cpu-total")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Network
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "net")
                  |> filter(fn: (r) => r._field == "bytes_recv" or r._field == "bytes_sent")
                  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 3
          xPos: 3
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "load1")
                 |> last()
                  |> yield(name: "mean")
          width: 2
          xPos: 5
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              label: Load
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "load1" or r._field == "load5" or r._field == "load15")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 6
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Processes
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "processes")
                  |> filter(fn: (r) => r._field == "running" or r._field == "blocked" or r._field == "idle" or r._field == "unknown")
                  |> aggregateWindow(every: v.windowPeriod, fn: max)
                  |> yield(name: "max")
          width: 3
          xPos: 6
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Total Memory
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "mem")
                  |> filter(fn: (r) => r._field == "total")
                  |> last()
                  |> map(fn: (r) => ({r with _value: float(v: r._value) / 1024.0 / 1024.0 / 1024.0}))
                  |> yield(name: "last")
          suffix: ' GB'
          width: 2
          xPos: 7
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
            - hex: '#8F8AF4'
              id: c2f922df-60a1-4471-91fc-c16427e7fcfb
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#A51414'
              id: 330f7fee-d44e-4a15-b2d6-2330178ec203
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#F4CF31'
              id: e3c73eb3-665a-414b-afdd-1686c9b962d9
              name: Do Androids Dream of Electric Sheep?
              type: scale
          decimalPlaces: 1
          height: 4
          kind: Single_Stat_Plus_Line
          name: Memory Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "mem")
                  |> filter(fn: (r) => r._field == "used_percent")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          suffix: '%'
          width: 3
          xPos: 9
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Swap
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "swap")
                  |> filter(fn: (r) => r._field == "total" or r._field == "used")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 9
          yPos: 5
    description: A collection of useful visualizations for monitoring your system stats
    name: System
---
apiVersion: influxdata.com/v2alpha1
kind: Dashboard
metadata:
    name: focused-leakey-3af001
spec:
    charts:
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: This dashboard gives you an overview of System metrics with metrics from `system`, `mem`, `diskio`, `swap` and `net` measurements. See the [Telegraf Documentation](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/system) for help configuring these plugins.
          width: 12
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          height: 1
          kind: Single_Stat
          name: System Uptime
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "uptime")
                   |> last()
                   |> map(fn: (r) => ({r with _value: r._value / 86400}))
                  |> yield(name: "last")
          suffix: ' days'
          width: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "disk")
                  |> filter(fn: (r) => r._field == "used_percent")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk IO
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "diskio")
                  |> filter(fn: (r) => r._field == "read_bytes" or r._field == "write_bytes")
                  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 3
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: nCPUs
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "n_cpus")
                  |> last()
                  |> yield(name: "last")
          suffix: ' cpus'
          width: 2
          xPos: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: CPU Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "cpu")
                  |> filter(fn: (r) => r._field == "usage_user" or r._field == "usage_system" or r._field == "usage_idle")
                  |> filter(fn: (r) => r.cpu == "cpu-total")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Network
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "net")
                  |> filter(fn: (r) => r._field == "bytes_recv" or r._field == "bytes_sent")
                  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 3
          xPos: 3
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "load1")
                 |> last()
                  |> yield(name: "mean")
          width: 2
          xPos: 5
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              label: Load
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "load1" or r._field == "load5" or r._field == "load15")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 6
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Processes
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "processes")
                  |> filter(fn: (r) => r._field == "running" or r._field == "blocked" or r._field == "idle" or r._field == "unknown")
                  |> aggregateWindow(every: v.windowPeriod, fn: max)
                  |> yield(name: "max")
          width: 3
          xPos: 6
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Total Memory
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "mem")
                  |> filter(fn: (r) => r._field == "total")
                  |> last()
                  |> map(fn: (r) => ({r with _value: float(v: r._value) / 1024.0 / 1024.0 / 1024.0}))
                  |> yield(name: "last")
          suffix: ' GB'
          width: 2
          xPos: 7
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
            - hex: '#8F8AF4'
              id: c2f922df-60a1-4471-91fc-c16427e7fcfb
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#A51414'
              id: 330f7fee-d44e-4a15-b2d6-2330178ec203
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#F4CF31'
              id: e3c73eb3-665a-414b-afdd-1686c9b962d9
              name: Do Androids Dream of Electric Sheep?
              type: scale
          decimalPlaces: 1
          height: 4
          kind: Single_Stat_Plus_Line
          name: Memory Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "mem")
                  |> filter(fn: (r) => r._field == "used_percent")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          suffix: '%'
          width: 3
          xPos: 9
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Swap
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "swap")
                  |> filter(fn: (r) => r._field == "total" or r._field == "used")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 9
          yPos: 5
    description: A collection of useful visualizations for monitoring your system stats
    name: System
---
apiVersion: influxdata.com/v2alpha1
kind: Dashboard
metadata:
    name: friendly-banach-7af001
spec:
    associations:
        - kind: Label
          name: elastic-pike-baf009
        - kind: Label
          name: xenodochial-pascal-baf001
    charts:
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: '# Nodes Overview'
          width: 7
        - colors:
            - hex: '#545667'
              name: graphite
              type: background
          decimalPlaces: 2
          fieldOptions:
            - displayName: _time
              fieldName: _time
            - displayName: Name
              fieldName: _value
              visible: true
          height: 3
          kind: Table
          name: Current and Past Nodes
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_node")
                  //|> filter(fn: (r) => r._field == "cpu_usage_nanocores")
                  |> last()
                  |> keep(columns: ["node_name", "_time"])
                  |> rename(columns: {node_name: "_value"})
                  |> group(columns: ["node_name"], mode:"by")
                  |> unique(column: "_value")
                //  |> sort(columns: "_time")
          tableOptions:
            sortBy: _time
            verticalTimeAxis: true
          timeFormat: YYYY/MM/DD HH:mm:ss
          width: 5
          yPos: 1
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: '# CPU Metrics'
          width: 5
          yPos: 4
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: nanocores
              name: "y"
              scale: linear
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          geom: monotoneX
          height: 5
          kind: Xy
          name: CPU Usage
          position: overlaid
          queries:
            - query: "import \"regexp\"\nfrom(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r._measurement == \"kubernetes_node\")\n  |> filter(fn: (r) => r._field == \"cpu_usage_nanocores\")\n//    |> map(fn: (r) => ({ r with node_name: \n//   regexp.replaceAllString(r: /placelongnamehere/, v: r.node_name, t: \"..\")\n//    }))\n  |> group(columns: [\"node_name\"] )\n  |> aggregateWindow(every: v.windowPeriod, fn: last)\n  |> yield(name: \"last\")"
          width: 5
          xCol: _time
          yCol: _value
          yPos: 5
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: '# Memory Consumption Metrics'
          width: 7
          yPos: 10
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              label: bytes
              name: "y"
              scale: linear
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          geom: monotoneX
          height: 5
          kind: Xy
          name: Memory Usage Bytes
          queries:
            - query: "import \"regexp\"\nfrom(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r._measurement == \"kubernetes_node\")\n  |> filter(fn: (r) => r._field == \"memory_usage_bytes\")\n  |> keep(columns: [\"_time\",\"_value\",\"node_name\"])\n  |> aggregateWindow(every: v.windowPeriod, fn: last)\n//    |> map(fn: (r) => ({ r with node_name: \n//    regexp.replaceAllString(r: /placelongnamehere/, v: r.node_name, t: \"..\")\n//     }))\n  |> yield(name: \"last\")"
          width: 5
          yPos: 11
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: '# Filesystem Metrics'
          width: 7
          yPos: 16
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          geom: line
          height: 5
          kind: Xy
          name: Filesystem capacity / used
          position: overlaid
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_node")
                  |> filter(fn: (r) => r._field == "fs_used_bytes" or r._field == "fs_capacity_bytes")
                  |> aggregateWindow(every: v.windowPeriod, fn: last)
                  |> yield(name: "last")
          width: 7
          xCol: _time
          yCol: _value
          yPos: 17
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: '# Network Consumption Metrics'
          width: 7
          yPos: 22
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              label: Rate
              name: "y"
              scale: linear
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          geom: line
          height: 4
          kind: Xy
          name: Network tx/rx
          position: overlaid
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_node")
                  |> filter(fn: (r) => r._field == "network_rx_bytes" or r._field == "network_tx_bytes")
                  |> aggregateWindow(every: v.windowPeriod, fn: last)
                  |> yield(name: "last")
          width: 7
          xCol: _time
          yCol: _value
          yPos: 23
        - colors:
            - hex: '#545667'
              name: graphite
              type: text
            - hex: '#4ED8A0'
              name: rainforest
              type: text
              value: 2
          decimalPlaces: 2
          height: 3
          kind: Single_Stat
          name: Node Count
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_node")
                  |> keep(columns: ["node_name"])
                  |> rename(columns: {node_name: "_value"})
                  |> group(columns: ["table"], mode:"by")
                  |> unique() |> count()
          width: 2
          xPos: 5
          yPos: 1
        - colors:
            - hex: '#545667'
              name: graphite
              type: text
            - hex: '#545667'
              name: graphite
              type: text
              value: 100
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Pods capacity
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_node")
                  |> filter(fn: (r) => r._field == "capacity_pods")
                  |> last()
          width: 1
          xPos: 5
          yPos: 4
        - colors:
            - hex: '#383846'
              name: pepper
              type: text
            - hex: '#4591ED'
              name: ocean
              type: text
              value: 2
          decimalPlaces: 0
          height: 2
          kind: Single_Stat
          name: Allocatable CPU Cores
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_node")
                  |> filter(fn: (r) => r._field == "allocatable_cpu_cores")
                  |> aggregateWindow(every: v.windowPeriod, fn: last)
                  |> yield(name: "last")
          width: 1
          xPos: 5
          yPos: 5
        - axes:
            - name: x
          binCount: 30
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          height: 3
          kind: Histogram
          name: Nanocore Distribution By Node
          position: stacked
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_node")
                  |> filter(fn: (r) => r._field == "cpu_usage_nanocores")
                  |> group(columns: ["node_name"], mode:"by")
          width: 2
          xCol: _value
          xPos: 5
          yPos: 7
        - axes:
            - name: x
          binCount: 30
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          height: 5
          kind: Histogram
          name: Mem Distribution
          position: stacked
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_node")
                  |> filter(fn: (r) => r._field == "memory_usage_bytes")
                  |> keep(columns: ["_time","_value", "node_name"])
                  |> aggregateWindow(every: v.windowPeriod, fn: last)
                  |> yield(name: "last")
          width: 2
          xCol: _value
          xPos: 5
          yPos: 11
        - colors:
            - hex: '#383846'
              name: pepper
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Host Count
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_node")
                  |> keep(columns: ["host"])
                  |> rename(columns: {host: "_value"})
                  |> group(columns: ["table"], mode:"by")
                  |> unique() |> count()
          width: 1
          xPos: 6
          yPos: 4
        - colors:
            - hex: '#545667'
              name: graphite
              type: text
          decimalPlaces: 2
          height: 2
          kind: Single_Stat
          name: Average CPU Capacity
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_node")
                  |> filter(fn: (r) => r._field == "capacity_cpu_cores")
                  |> aggregateWindow(every: v.windowPeriod, fn: last)
                  |> movingAverage(n: 1)
          width: 1
          xPos: 6
          yPos: 5
        - height: 27
          kind: Markdown
          name: Name this Cell
          note: |
            # Kubernetes Node Metrics Legend

            **This dashboard can be used to display Kubernetes Node metrics. The K8S infrastrucure supports Google Cloud Platform.**

            [Download](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/kubernetes) and install Telegraf `Kubernetes` input plugin to your monitoring namespace to collect data. The measurement `kubernetes_node` is used. Set `v.bucket` variable.

            ### Basic K8S Concepts

            A K8S `cluster` consists of a set of worker machines called nodes. A `node` may be a VM or physical machine, depending on the cluster. Nodes host pods. `Pod` is a set of running containers.

            ### Application Description

            The monitored application consists of:

            1. Microservices providing REST APIs. Example technology stack can be based on eg "NodeJs > MySQL / Mongo app framework".
            2. Application provides administration web UI.
            3. Influxdata monitoring infrastructure, based on Telegraf plugins.

            Telegraf note: host = node; and in Telegraf the meaning of host = pod hostname


            ### CPU Units and Metrics

            | Unit | Description |
            | ---- | ----------- |
            | Nanocore | 1024 M = 1G = 1 CPU |


            `Allocatable` identifies the amount of compute resources available to pods. By explicitly reserving compute resources, the intention is to avoid overcommiting the node and not have system daemons compete with user pods.

            ### Memory

            Memory consumption. Based on the 'Memory usage bytes' metrics. Measure in bytes.

            ### Filesystem

            Filesystem consumption. Based on the 'filesystem used bytes' metrics.


            ### Network

            Network consumption, based on metrics of network bytes received / transferred.
          width: 5
          xPos: 7
    description: From Telegraf Kubernetes Input Plugin. The dashboard shows K8S Node metrics that are taken from an existing K8S environment. Google Cloud Platform is supported.
    name: Kubernetes Node Metrics
---
apiVersion: influxdata.com/v2alpha1
kind: Dashboard
metadata:
    name: goofy-meitner-faf001
spec:
    charts:
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: This dashboard gives you an overview of System metrics with metrics from `system`, `mem`, `diskio`, `swap` and `net` measurements. See the [Telegraf Documentation](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/system) for help configuring these plugins.
          width: 12
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          height: 1
          kind: Single_Stat
          name: System Uptime
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "uptime")
                   |> last()
                   |> map(fn: (r) => ({r with _value: r._value / 86400}))
                  |> yield(name: "last")
          suffix: ' days'
          width: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "disk")
                  |> filter(fn: (r) => r._field == "used_percent")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk IO
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "diskio")
                  |> filter(fn: (r) => r._field == "read_bytes" or r._field == "write_bytes")
                  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 3
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: nCPUs
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "n_cpus")
                  |> last()
                  |> yield(name: "last")
          suffix: ' cpus'
          width: 2
          xPos: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: CPU Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "cpu")
                  |> filter(fn: (r) => r._field == "usage_user" or r._field == "usage_system" or r._field == "usage_idle")
                  |> filter(fn: (r) => r.cpu == "cpu-total")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Network
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "net")
                  |> filter(fn: (r) => r._field == "bytes_recv" or r._field == "bytes_sent")
                  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 3
          xPos: 3
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "load1")
                 |> last()
                  |> yield(name: "mean")
          width: 2
          xPos: 5
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              label: Load
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "load1" or r._field == "load5" or r._field == "load15")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 6
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Processes
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "processes")
                  |> filter(fn: (r) => r._field == "running" or r._field == "blocked" or r._field == "idle" or r._field == "unknown")
                  |> aggregateWindow(every: v.windowPeriod, fn: max)
                  |> yield(name: "max")
          width: 3
          xPos: 6
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Total Memory
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "mem")
                  |> filter(fn: (r) => r._field == "total")
                  |> last()
                  |> map(fn: (r) => ({r with _value: float(v: r._value) / 1024.0 / 1024.0 / 1024.0}))
                  |> yield(name: "last")
          suffix: ' GB'
          width: 2
          xPos: 7
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
            - hex: '#8F8AF4'
              id: c2f922df-60a1-4471-91fc-c16427e7fcfb
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#A51414'
              id: 330f7fee-d44e-4a15-b2d6-2330178ec203
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#F4CF31'
              id: e3c73eb3-665a-414b-afdd-1686c9b962d9
              name: Do Androids Dream of Electric Sheep?
              type: scale
          decimalPlaces: 1
          height: 4
          kind: Single_Stat_Plus_Line
          name: Memory Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "mem")
                  |> filter(fn: (r) => r._field == "used_percent")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          suffix: '%'
          width: 3
          xPos: 9
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Swap
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "swap")
                  |> filter(fn: (r) => r._field == "total" or r._field == "used")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 9
          yPos: 5
    description: A collection of useful visualizations for monitoring your system stats
    name: System
---
apiVersion: influxdata.com/v2alpha1
kind: Dashboard
metadata:
    name: magical-jang-7af001
spec:
    associations:
        - kind: Label
          name: tender-johnson-baf007
        - kind: Label
          name: xenodochial-pascal-baf001
    charts:
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: '## Kubernetes Landscape - Overview'
          width: 7
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Pods in replicas
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_deployment")
                  |> filter(fn: (r) => r._field == "replicas_available")
                  |> last()
                  |> drop(columns: ["deployment_name"])
                  |> sum(column: "_value")
          width: 1
          yPos: 1
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: '## Containers List'
          width: 5
          yPos: 4
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
          fieldOptions:
            - visible: true
            - displayName: result
              fieldName: result
              visible: true
            - displayName: table
              fieldName: table
              visible: true
            - displayName: container_name
              fieldName: container_name
              visible: true
            - displayName: namespace
              fieldName: namespace
              visible: true
            - displayName: pod_name
              fieldName: pod_name
              visible: true
            - displayName: state
              fieldName: state
              visible: true
          height: 5
          kind: Table
          name: Running Containers
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_pod_container")
                  |> filter(fn: (r) => r._field == "state_code")
                  |> group(columns:["pod_name","container_name"])
                  |> last()
                  |> group(columns: ["host"])
                  |> keep(columns:["namespace","container_name","pod_name", "state"])
          tableOptions:
            verticalTimeAxis: true
          timeFormat: YYYY-MM-DD HH:mm:ss
          width: 7
          yPos: 5
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: '## Nodes CPU Usage'
          width: 5
          yPos: 10
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              label: nanocore
              name: "y"
              scale: linear
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          geom: line
          height: 4
          kind: Xy
          name: Pods CPU Usage in Nanocores
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_system_container")
                  |> filter(fn: (r) => r._field == "cpu_usage_nanocores")
                  |> filter(fn: (r) => r.container_name == "pods")
                  |> aggregateWindow(every: v.windowPeriod, fn: last)
                  |> yield(name: "last")
          shade: true
          width: 5
          xCol: _time
          yCol: _value
          yPos: 11
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: '## Memory Consumption'
          width: 6
          yPos: 15
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: B
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          geom: line
          height: 4
          kind: Xy
          name: Pods MEM usage in bytes
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_system_container")
                  |> filter(fn: (r) => r._field == "memory_usage_bytes")
                  |> filter(fn: (r) => r.container_name == "pods")
                  |> aggregateWindow(every: v.windowPeriod, fn: last)
                  |> yield(name: "last")
          shade: true
          width: 3
          yPos: 16
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Node memory
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_node")
                  |> filter(fn: (r) => r._field == "capacity_memory_bytes" or r._field == "allocatable_memory_bytes")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          shade: true
          width: 3
          xCol: _time
          yCol: _value
          yPos: 20
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Capacity Pods
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_node")
                  |> filter(fn: (r) => r._field == "allocatable_pods")
                  |> last()
                  |> drop(columns: ["node_name"])
                  |> sum(column: "_value")
          width: 1
          xPos: 1
          yPos: 1
        - colors:
            - hex: '#545667'
              name: graphite
              type: text
          decimalPlaces: 0
          height: 2
          kind: Single_Stat
          name: Allocatable Pods
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_node")
                  |> filter(fn: (r) => r._field == "allocatable_pods")
                  |> last()
                  |> drop(columns: ["node_name"])
                  |> sum(column: "_value")
          width: 2
          xPos: 2
          yPos: 1
        - colors:
            - hex: '#4ED8A0'
              name: rainforest
              type: text
            - hex: '#FFB94A'
              name: pineapple
              type: text
              value: 30
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Running Pods
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_pod_container")
                  |> filter(fn: (r) => r._field == "state_code")
                  |> filter(fn: (r) => r.state == "running")
                  |> last()
                  |> drop(columns: ["container_name","node_name"])
                  |> distinct(column: "pod_name")
                  |> drop(columns: ["pod_name"])
                  |> count()
          width: 1
          xPos: 3
          yPos: 3
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 7
          kind: Xy
          name: Resource memory
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_pod_container")
                  |> filter(fn: (r) => r._field == "resource_requests_memory_bytes")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          shade: true
          width: 4
          xCol: _time
          xPos: 3
          yCol: _value
          yPos: 16
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Replicas count
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_deployment")
                  |> filter(fn: (r) => r._field == "replicas_available")
                  |> last()
                  |> drop(columns: ["deployment_name"])
                  |> count(column: "_value")
          width: 1
          xPos: 4
          yPos: 1
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
            - hex: '#4ED8A0'
              name: rainforest
              type: text
              value: 20
          decimalPlaces: 2
          height: 2
          kind: Single_Stat
          name: Running Containers
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_pod_container")
                  |> filter(fn: (r) => r._field == "state_code")
                  |> filter(fn: (r) => r.state == "running")
                  |> last()
                  |> drop(columns: ["container_name","pod_name","node_name"])
                  |> count()
          width: 2
          xPos: 5
          yPos: 1
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: '## CPU Cores'
          width: 2
          xPos: 5
          yPos: 10
        - colors:
            - hex: '#545667'
              name: graphite
              type: text
          decimalPlaces: 0
          height: 2
          kind: Single_Stat
          name: Allocatable
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_node")
                  |> filter(fn: (r) => r._field == "allocatable_cpu_cores")
                  |> last()
                  |> drop(columns: ["node_name"])
                  |> sum(column: "_value")
                  |> yield(name: "last")
          width: 1
          xPos: 5
          yPos: 11
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: monotoneX
          height: 2
          kind: Xy
          name: Resource Requests CPU
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_pod_container")
                  |> filter(fn: (r) => r._field == "resource_requests_millicpu_units")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          shade: true
          width: 2
          xCol: _time
          xPos: 5
          yCol: _value
          yPos: 13
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
          decimalPlaces: 2
          height: 2
          kind: Single_Stat
          name: K8s Capacity CPUs
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_node")
                  |> filter(fn: (r) => r._field == "capacity_cpu_cores")
                  |> last()
                  |> drop(columns: ["node_name"])
                  |> sum(column: "_value")
                  |> yield(name: "last")
          width: 1
          xPos: 6
          yPos: 11
        - colors:
            - hex: '#7A65F2'
              name: star
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Allocatable memory
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_node")
                  |> filter(fn: (r) => r._field == "allocatable_memory_bytes")
                  |> last()
                  |> map(fn: (r) => ({r with _value: r._value / 1073741824}))
                  |> drop(columns: ["node_name"])
                  |> sum(column: "_value")
          suffix: ' GB'
          width: 1
          xPos: 6
          yPos: 15
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: '## DaemonSets'
          width: 5
          xPos: 7
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 5
          kind: Xy
          name: DaemonSets
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_daemonset")
                  |> filter(fn: (r) => r._field == "number_ready" or r._field == "number_available" or r._field == "number_unavailable" or r._field == "updated_number_scheduled" or r._field == "number_misscheduled")
                  |> group(columns: ["daemonset_name","_field"])
          width: 5
          xCol: _time
          xPos: 7
          yCol: _value
          yPos: 1
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: '## Resources'
          width: 5
          xPos: 7
          yPos: 6
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Resource limit milliscpu
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_pod_container" and  r._field == "resource_limits_millicpu_units")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
          shade: true
          width: 5
          xCol: _time
          xPos: 7
          yCol: _value
          yPos: 7
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: '## Persistent Volumes Status'
          width: 5
          xPos: 7
          yPos: 10
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
          fieldOptions:
            - visible: true
            - displayName: result
              fieldName: result
              visible: true
            - displayName: table
              fieldName: table
              visible: true
            - displayName: phase
              fieldName: phase
              visible: true
            - displayName: pv_name
              fieldName: pv_name
              visible: true
          height: 7
          kind: Table
          name: Persistent volumes status
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r._measurement == "kubernetes_persistentvolume")

                  |> filter(fn: (r) => r._field == "phase_type")
                  |> group(columns: ["host", "_measurement", "pv_name", "phase" ,"node_name"], mode:"by")
                  |> last()
                  |> keep(columns: ["pv_name", "phase"])
          tableOptions:
            verticalTimeAxis: true
          timeFormat: YYYY-MM-DD HH:mm:ss
          width: 5
          xPos: 7
          yPos: 11
    description: From Telegraf inputs.kube_inventory plugin - A collection of useful visualizations for monitoring your Kubernetes Control Plane
    name: Kubernetes Inventory
---
apiVersion: influxdata.com/v2alpha1
kind: Dashboard
metadata:
    name: quirky-tharp-3af001
spec:
    charts:
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: min
            - hex: '#9394FF'
              name: comet
              type: max
              value: 100
          decimalPlaces: 2
          height: 3
          kind: Gauge
          name: CPU Usage
          queries:
            - query: |-
                from(bucket: "haproxy")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "cpu")
                  |> filter(fn: (r) => r["_field"] == "usage_system")
          width: 3
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          geom: monotoneX
          height: 3
          kind: Xy
          legendOpacity: 0.56
          name: Bytes IN
          position: overlaid
          queries:
            - query: |-
                from(bucket: "haproxy")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "haproxy")
                  |> filter(fn: (r) => r["_field"] == "bin")
                  |> derivative(unit: v.windowPeriod, nonNegative: true)
                  |> yield(name: "nonnegative derivative")
          shade: true
          width: 6
          xCol: _time
          yCol: _value
          yPos: 3
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          geom: monotoneX
          height: 3
          kind: Xy
          name: Active Sessions
          position: overlaid
          queries:
            - query: |-
                from(bucket: "haproxy")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "haproxy")
                  |> filter(fn: (r) => r["_field"] == "scur")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean)
                  |> yield(name: "mean")
          shade: true
          width: 4
          xCol: _time
          yCol: _value
          yPos: 6
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          geom: monotoneX
          height: 3
          kind: Xy
          name: total number of HTTP requests received
          position: overlaid
          queries:
            - query: |-
                from(bucket: "haproxy")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "haproxy")
                  |> filter(fn: (r) => r["_field"] == "req_tot")
                  |> derivative(unit: v.windowPeriod, nonNegative: true)
                  |> yield(name: "nonnegative derivative")
          shade: true
          width: 4
          xCol: _time
          yCol: _value
          yPos: 9
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Uptime
          queries:
            - query: |-
                from(bucket: "haproxy")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "system")
                  |> filter(fn: (r) => r["_field"] == "uptime_format")
          width: 3
          xPos: 3
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
          decimalPlaces: 2
          height: 2
          kind: Single_Stat
          name: Memory Used (%)
          queries:
            - query: |-
                from(bucket: "haproxy")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "mem")
                  |> filter(fn: (r) => r["_field"] == "used_percent")
          suffix: ' %'
          width: 2
          xPos: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          geom: monotoneX
          height: 3
          kind: Xy
          name: Sessions
          position: overlaid
          queries:
            - query: |-
                from(bucket: "haproxy")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "haproxy")
                  |> filter(fn: (r) => r["_field"] == "stot")
                  |> derivative(unit: v.windowPeriod, nonNegative: false)
                  |> yield(name: "derivative")
          shade: true
          width: 4
          xCol: _time
          xPos: 4
          yCol: _value
          yPos: 6
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          geom: monotoneX
          height: 3
          kind: Xy
          name: Denied Request
          position: overlaid
          queries:
            - query: |-
                from(bucket: "haproxy")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "haproxy")
                  |> filter(fn: (r) => r["_field"] == "dreq")
                  |> derivative(unit: v.windowPeriod, nonNegative: false)
                  |> yield(name: "derivative")
          shade: true
          width: 4
          xCol: _time
          xPos: 4
          yCol: _value
          yPos: 9
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          geom: line
          height: 2
          kind: Xy
          name: Queue Size
          position: overlaid
          queries:
            - query: |-
                from(bucket: "haproxy")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "haproxy")
                  |> filter(fn: (r) => r["_field"] == "qcur")
                  |> aggregateWindow(every: v.windowPeriod, fn: last)
                  |> yield(name: "last")
          width: 1
          xCol: _time
          xPos: 5
          yCol: _value
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          geom: monotoneX
          height: 3
          kind: Xy
          name: Total Response by HTTP Code
          position: overlaid
          queries:
            - query: |-
                from(bucket: "haproxy")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "haproxy")
                  |> filter(fn: (r) => r["_field"] == "http_response.1xx" or r["_field"] == "http_response.2xx" or r["_field"] == "http_response.3xx" or r["_field"] == "http_response.4xx" or r["_field"] == "http_response.5xx" or r["_field"] == "http_response.other")
                  |> derivative(unit: v.windowPeriod, nonNegative: false)
                  |> yield(name: "derivative")
          shade: true
          width: 6
          xCol: _time
          xPos: 6
          yCol: _value
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          geom: monotoneX
          height: 3
          kind: Xy
          name: Bytes OUT
          position: overlaid
          queries:
            - query: |-
                from(bucket: "haproxy")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "haproxy")
                  |> filter(fn: (r) => r["_field"] == "bout")
                  |> derivative(unit: v.windowPeriod, nonNegative: true)
                  |> yield(name: "nonnegative derivative")
          shade: true
          width: 6
          xCol: _time
          xPos: 6
          yCol: _value
          yPos: 3
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          geom: line
          height: 3
          kind: Xy
          name: Servers Up
          position: overlaid
          queries:
            - query: |-
                from(bucket: "haproxy")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "haproxy")
                  |> filter(fn: (r) => r["_field"] == "active_servers")
                  |> sort()
                  |> yield(name: "sort")
          shade: true
          width: 4
          xCol: _time
          xPos: 8
          yCol: _value
          yPos: 6
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
          colors:
            - hex: '#31C0F6'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#A500A5'
              name: Nineteen Eighty Four
              type: scale
            - hex: '#FF7E27'
              name: Nineteen Eighty Four
              type: scale
          geom: monotoneX
          height: 3
          kind: Xy
          name: Number of request errors
          position: overlaid
          queries:
            - query: |-
                from(bucket: "haproxy")
                  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
                  |> filter(fn: (r) => r["_measurement"] == "haproxy")
                  |> filter(fn: (r) => r["_field"] == "ereq")
                  |> derivative(unit: v.windowPeriod, nonNegative: false)
                  |> yield(name: "derivative")
          shade: true
          width: 4
          xCol: _time
          xPos: 8
          yCol: _value
          yPos: 9
    name: haproxy
---
apiVersion: influxdata.com/v2alpha1
kind: Dashboard
metadata:
    name: strange-euler-faf001
spec:
    charts:
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: This dashboard gives you an overview of System metrics with metrics from `system`, `mem`, `diskio`, `swap` and `net` measurements. See the [Telegraf Documentation](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/system) for help configuring these plugins.
          width: 12
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          height: 1
          kind: Single_Stat
          name: System Uptime
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "uptime")
                   |> last()
                   |> map(fn: (r) => ({r with _value: r._value / 86400}))
                  |> yield(name: "last")
          suffix: ' days'
          width: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "disk")
                  |> filter(fn: (r) => r._field == "used_percent")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk IO
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "diskio")
                  |> filter(fn: (r) => r._field == "read_bytes" or r._field == "write_bytes")
                  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 3
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: nCPUs
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "n_cpus")
                  |> last()
                  |> yield(name: "last")
          suffix: ' cpus'
          width: 2
          xPos: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: CPU Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "cpu")
                  |> filter(fn: (r) => r._field == "usage_user" or r._field == "usage_system" or r._field == "usage_idle")
                  |> filter(fn: (r) => r.cpu == "cpu-total")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Network
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "net")
                  |> filter(fn: (r) => r._field == "bytes_recv" or r._field == "bytes_sent")
                  |> aggregateWindow(every: v.windowPeriod, fn: last, createEmpty: false)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 3
          xPos: 3
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "load1")
                 |> last()
                  |> yield(name: "mean")
          width: 2
          xPos: 5
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              label: Load
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "system")
                  |> filter(fn: (r) => r._field == "load1" or r._field == "load5" or r._field == "load15")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 6
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Processes
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "processes")
                  |> filter(fn: (r) => r._field == "running" or r._field == "blocked" or r._field == "idle" or r._field == "unknown")
                  |> aggregateWindow(every: v.windowPeriod, fn: max)
                  |> yield(name: "max")
          width: 3
          xPos: 6
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Total Memory
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "mem")
                  |> filter(fn: (r) => r._field == "total")
                  |> last()
                  |> map(fn: (r) => ({r with _value: float(v: r._value) / 1024.0 / 1024.0 / 1024.0}))
                  |> yield(name: "last")
          suffix: ' GB'
          width: 2
          xPos: 7
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          colors:
            - hex: '#00C9FF'
              id: base
              name: laser
              type: text
            - hex: '#8F8AF4'
              id: c2f922df-60a1-4471-91fc-c16427e7fcfb
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#A51414'
              id: 330f7fee-d44e-4a15-b2d6-2330178ec203
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#F4CF31'
              id: e3c73eb3-665a-414b-afdd-1686c9b962d9
              name: Do Androids Dream of Electric Sheep?
              type: scale
          decimalPlaces: 1
          height: 4
          kind: Single_Stat_Plus_Line
          name: Memory Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "mem")
                  |> filter(fn: (r) => r._field == "used_percent")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          suffix: '%'
          width: 3
          xPos: 9
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Swap
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "swap")
                  |> filter(fn: (r) => r._field == "total" or r._field == "used")
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xPos: 9
          yPos: 5
    description: A collection of useful visualizations for monitoring your system stats
    name: System
---
apiVersion: influxdata.com/v2alpha1
kind: Dashboard
metadata:
    name: trusting-chebyshev-faf001
spec:
    associations:
        - kind: Label
          name: lucid-tereshkova-baf003
    charts:
        - height: 1
          kind: Markdown
          name: Name this Cell
          note: This dashboard gives you an overview of your Windows System metrics and will work with the default Windows Telegraf config. See the [Telegraf Win Perf Counters Documentation](https://github.com/influxdata/telegraf/tree/master/plugins/inputs/win_perf_counters) for more information.
          width: 12
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
          height: 1
          kind: Single_Stat
          name: System Uptime
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "win_system")
                  |> filter(fn: (r) => r._field == "System_Up_Time")
                  |> filter(fn: (r) => r.host == v.windows_host)
                  |> last()
                  |> map(fn: (r) => ({r with _value: r._value / 86400.0}))
                  |> yield(name: "last")
          suffix: ' days'
          width: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "win_disk")
                  |> filter(fn: (r) => r._field == "Percent_Free_Space")
                  |> filter(fn: (r) => r.host == v.windows_host)
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> map(fn: (r) => ({ r with _value: 100.0 - r._value }))
                  |> set(key: "_field", value: "Percent Used Space")
                  //|> yield(name: "mean")
          width: 3
          xCol: _time
          yCol: _value
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Disk IO (bytes/sec)
          position: overlaid
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "win_diskio")
                  |> filter(fn: (r) => r._field =~ /_Bytes_persec$/)
                  |> filter(fn: (r) => r.host == v.windows_host)
                  |> derivative(unit: 1s, nonNegative: false)
                  |> yield(name: "derivative")
          width: 4
          xCol: _time
          yCol: _value
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Processor Queue Length
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "win_system")
                  |> filter(fn: (r) => r._field == "Processor_Queue_Length")
                  |> filter(fn: (r) => r.host == v.windows_host)
                  |> last()
          width: 2
          xPos: 3
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: CPU Usage
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "win_cpu")
                  |> filter(fn: (r) => r.instance == "_Total")
                  |> filter(fn: (r) => r._field =~ /^Percent_/)
                  |> filter(fn: (r) => r.host == v.windows_host)
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> drop(columns: ["objectname"])
          width: 3
          xPos: 3
          yPos: 2
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              label: Bytes
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Network
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "win_net")
                  |> filter(fn: (r) => r.host == v.windows_host)
                  |> filter(fn: (r) => r._field =~ /^Bytes_(Received|Sent)_persec$/)
                  |> derivative(unit: 1s, nonNegative: false)
          width: 4
          xCol: _time
          xPos: 4
          yCol: _value
          yPos: 5
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: System Calls / Sec
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "win_system")
                  |> filter(fn: (r) => r._field == "System_Calls_persec")
                  |> filter(fn: (r) => r.host == v.windows_host)
                  |> last()
          width: 2
          xPos: 5
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              label: Load
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: System Load
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "win_system")
                  |> filter(fn: (r) => r._field =~ /_persec$/)
                  |> filter(fn: (r) => r.host == v.windows_host)
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xCol: _time
          xPos: 6
          yCol: _value
          yPos: 2
        - colors:
            - hex: '#00C9FF'
              name: laser
              type: text
          decimalPlaces: 2
          height: 1
          kind: Single_Stat
          name: Available Memory
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "win_mem")
                  |> filter(fn: (r) => r._field == "Available_Bytes")
                  |> filter(fn: (r) => r.host == v.windows_host)
                  |> last()
                  |> map(fn: (r) => ({r with _value: float(v: r._value) / 1024.0 / 1024.0 / 1024.0}))
                  |> yield(name: "last")
          suffix: ' GB'
          width: 2
          xPos: 7
          yPos: 1
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "2"
              name: "y"
              scale: linear
            - base: "10"
              name: y2
              scale: linear
          geom: line
          height: 3
          kind: Xy
          name: Swap
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "win_swap")
                  |> filter(fn: (r) => r.host == v.windows_host)
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 4
          xCol: _time
          xPos: 8
          yCol: _value
          yPos: 5
        - axes:
            - base: "10"
              name: x
              scale: linear
            - base: "10"
              name: "y"
              scale: linear
              suffix: '%'
            - base: "10"
              name: y2
              scale: linear
          colors:
            - hex: '#00C9FF'
              name: laser
              type: text
            - hex: '#8F8AF4'
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#A51414'
              name: Do Androids Dream of Electric Sheep?
              type: scale
            - hex: '#F4CF31'
              name: Do Androids Dream of Electric Sheep?
              type: scale
          decimalPlaces: 1
          height: 4
          kind: Single_Stat_Plus_Line
          name: Available Memory (bytes)
          queries:
            - query: |-
                from(bucket: v.bucket)
                  |> range(start: v.timeRangeStart)
                  |> filter(fn: (r) => r._measurement == "win_mem")
                  |> filter(fn: (r) => r._field == "Available_Bytes")
                  |> filter(fn: (r) => r.host == v.windows_host)
                  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
                  |> yield(name: "mean")
          width: 3
          xCol: _time
          xPos: 9
          yCol: _value
          yPos: 1
    description: A collection of useful visualizations for monitoring your Windows system stats
    name: Windows System
---
apiVersion: influxdata.com/v2alpha1
kind: Telegraf
metadata:
    name: dangling-tharp-7af005
spec:
    config: "\n# Configuration for telegraf agent\n[agent]\n  ## Default data collection interval for all inputs\n  interval = \"10s\"\n  ## Rounds collection interval to 'interval'\n  ## ie, if interval=\"10s\" then always collect on :00, :10, :20, etc.\n  round_interval = true\n\n  ## Telegraf will send metrics to outputs in batches of at most\n  ## metric_batch_size metrics.\n  ## This controls the size of writes that Telegraf sends to output plugins.\n  metric_batch_size = 1000\n\n  ## For failed writes, telegraf will cache metric_buffer_limit metrics for each\n  ## output, and will flush this buffer on a successful write. Oldest metrics\n  ## are dropped first when this buffer fills.\n  ## This buffer only fills when writes fail to output plugin(s).\n  metric_buffer_limit = 10000\n\n  ## Collection jitter is used to jitter the collection by a random amount.\n  ## Each plugin will sleep for a random time within jitter before collecting.\n  ## This can be used to avoid many plugins querying things like sysfs at the\n  ## same time, which can have a measurable effect on the system.\n  collection_jitter = \"0s\"\n\n  ## Default flushing interval for all outputs. Maximum flush_interval will be\n  ## flush_interval + flush_jitter\n  flush_interval = \"10s\"\n  ## Jitter the flush interval by a random amount. This is primarily to avoid\n  ## large write spikes for users running a large number of telegraf instances.\n  ## ie, a jitter of 5s and interval 10s means flushes will happen every 10-15s\n  flush_jitter = \"0s\"\n\n  ## By default or when set to \"0s\", precision will be set to the same\n  ## timestamp order as the collection interval, with the maximum being 1s.\n  ##   ie, when interval = \"10s\", precision will be \"1s\"\n  ##       when interval = \"250ms\", precision will be \"1ms\"\n  ## Precision will NOT be used for service inputs. It is up to each individual\n  ## service input to set the timestamp at the appropriate precision.\n  ## Valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\".\n  precision = \"\"\n\n  ## Logging configuration:\n  ## Run telegraf with debug log messages.\n  debug = false\n  ## Run telegraf in quiet mode (error log messages only).\n  quiet = false\n  ## Specify the log file name. The empty string means to log to stderr.\n  logfile = \"\"\n\n  ## Override default hostname, if empty use os.Hostname()\n  hostname = \"\"\n  ## If set to true, do no set the \"host\" tag in the telegraf agent.\n  omit_hostname = false\n[[outputs.influxdb_v2]]\t\n  ## The URLs of the InfluxDB cluster nodes.\n  ##\n  ## Multiple URLs can be specified for a single cluster, only ONE of the\n  ## urls will be written to each interval.\n  ## urls exp: http://127.0.0.1:8086\n  urls = [\"https://influx.visiba.cloud\"]\n\n  ## Token for authentication.\n  token = \"$INFLUX_TOKEN\"\n\n  ## Organization is the name of the organization you wish to write to; must exist.\n  organization = \"Visiba\"\n\n  ## Destination bucket to write into.\n  bucket = \"uptime\"\n\n\n# Reads metrics from a SSL certificate\n[[inputs.x509_cert]]\n  ## List certificate sources, support wildcard expands for files\n  ## Prefix your entry with 'file://' if you intend to use relative paths\n  sources = [\n            \"https://www.visibacare.com:443\", \n            \"https://se.visibacare.com:443\", \n            \"https://no.visibacare.com:443\", \n            \"https://mittvardmote.vgregion.se:443\",\n            \"https://fi.visibacare.com:443\", \n            \"https://nl.visibacare.com:443\", \n            \"https://gb.visibacare.com:443\", \n            \"https://rjl.visibacare.com:443\", \n            \"https://dalarna.visibacare.com:443\", \n            \"https://api.redrobin.ai:443\",\n            \"https://analytics.visibacare.com:443\",\n            \"https://analytics.visibacare.com:443\",\n            \"https://global.visibacare.com:443\",\n            \"https://dev1.vcare.pl:443\"\n            ]\n\n  ## Timeout for SSL connection\n  # timeout = \"5s\"\n\n  ## Pass a different name into the TLS request (Server Name Indication).\n  ## This is synonymous with tls_server_name, and only one of the two\n  ## options may be specified at one time.\n  ##   example: server_name = \"myhost.example.org\"\n  # server_name = \"myhost.example.org\"\n\n  ## Optional TLS Config\n  # tls_ca = \"/etc/telegraf/ca.pem\"\n  # tls_cert = \"/etc/telegraf/cert.pem\"\n  # tls_key = \"/etc/telegraf/key.pem\"\n  # tls_server_name = \"myhost.example.org\"\n"
    description: Add domains to this configuration
    name: x509 Certificate Check
---
apiVersion: influxdata.com/v2alpha1
kind: Telegraf
metadata:
    name: lucid-gates-baf001
spec:
    associations:
        - kind: Label
          name: elastic-pike-baf009
        - kind: Label
          name: tender-johnson-baf007
    config: |
        [agent]
          interval = "1m"
          round_interval = true
          flush_interval = "10s"
          metric_buffer_limit = 50000
          debug = true
        [[outputs.influxdb_v2]]	
          urls = ["$INFLUX_HOST"]
          token = "$INFLUX_TOKEN"
          ## Organization is the name of the organization you wish to write to; must exist.
          organization = "$INFLUX_ORG"
          ## Destination bucket to write into.
          bucket = "demo"
        [[inputs.prometheus]]
          monitor_kubernetes_pods = true
          kubernetes_label_selector = "app=influxdb"
          metric_version = 2
          monitor_kubernetes_pods_namespace = ""
          kubernetes_services = ["http://kube-state-metrics.kube-system.svc.cluster.local:8080/metrics","https://kubernetes.default.svc.cluster.local/metrics"]
          bearer_token = "/run/secrets/kubernetes.io/serviceaccount/token"
          insecure_skip_verify = true
        [[inputs.kube_inventory]]
          url = "https://kubernetes.default"
          bearer_token = "/run/secrets/kubernetes.io/serviceaccount/token"
          namespace = ""
          insecure_skip_verify = true
          resource_exclude = []
          resource_include = []
    name: K8S Configuration
---
apiVersion: influxdata.com/v2alpha1
kind: Telegraf
metadata:
    name: modest-bardeen-7af003
spec:
    config: |
        # Configuration for telegraf agent
        [agent]
          ## Default data collection interval for all inputs
          interval = "1m"
          ## Rounds collection interval to 'interval'
          ## ie, if interval="10s" then always collect on :00, :10, :20, etc.
          round_interval = true

          ## Telegraf will send metrics to outputs in batches of at most
          ## metric_batch_size metrics.
          ## This controls the size of writes that Telegraf sends to output plugins.
          metric_batch_size = 1000

          ## For failed writes, telegraf will cache metric_buffer_limit metrics for each
          ## output, and will flush this buffer on a successful write. Oldest metrics
          ## are dropped first when this buffer fills.
          ## This buffer only fills when writes fail to output plugin(s).
          metric_buffer_limit = 10000

          ## Collection jitter is used to jitter the collection by a random amount.
          ## Each plugin will sleep for a random time within jitter before collecting.
          ## This can be used to avoid many plugins querying things like sysfs at the
          ## same time, which can have a measurable effect on the system.
          collection_jitter = "0s"

          ## Default flushing interval for all outputs. Maximum flush_interval will be
          ## flush_interval + flush_jitter
          flush_interval = "10s"
          ## Jitter the flush interval by a random amount. This is primarily to avoid
          ## large write spikes for users running a large number of telegraf instances.
          ## ie, a jitter of 5s and interval 10s means flushes will happen every 10-15s
          flush_jitter = "0s"

          ## By default or when set to "0s", precision will be set to the same
          ## timestamp order as the collection interval, with the maximum being 1s.
          ##   ie, when interval = "10s", precision will be "1s"
          ##       when interval = "250ms", precision will be "1ms"
          ## Precision will NOT be used for service inputs. It is up to each individual
          ## service input to set the timestamp at the appropriate precision.
          ## Valid time units are "ns", "us" (or "µs"), "ms", "s".
          precision = ""

          ## Logging configuration:
          ## Run telegraf with debug log messages.
          debug = false
          ## Run telegraf in quiet mode (error log messages only).
          quiet = false
          ## Specify the log file name. The empty string means to log to stderr.
          logfile = ""

          ## Override default hostname, if empty use os.Hostname()
          hostname = ""
          ## If set to true, do no set the "host" tag in the telegraf agent.
          omit_hostname = false
        [[outputs.influxdb_v2]]	
          ## The URLs of the InfluxDB cluster nodes.
          ##
          ## Multiple URLs can be specified for a single cluster, only ONE of the
          ## urls will be written to each interval.
          ## urls exp: http://127.0.0.1:8086
          urls = ["https://influx.visiba.cloud"]

          ## Token for authentication.
          token = "$INFLUX_TOKEN"

          ## Organization is the name of the organization you wish to write to; must exist.
          organization = "Visiba"

          ## Destination bucket to write into.
          bucket = "telegraf"
        [[inputs.cpu]]
          ## Whether to report per-cpu stats or not
          percpu = true
          ## Whether to report total system cpu stats or not
          totalcpu = true
          ## If true, collect raw CPU time metrics.
          collect_cpu_time = false
          ## If true, compute and report the sum of all non-idle CPU states.
          report_active = false
        [[inputs.disk]]
          ## By default stats will be gathered for all mount points.
          ## Set mount_points will restrict the stats to only the specified mount points.
          # mount_points = ["/"]
          ## Ignore mount points by filesystem type.
          ignore_fs = ["tmpfs", "devtmpfs", "devfs", "overlay", "aufs", "squashfs"]
        [[inputs.diskio]]
        [[inputs.mem]]
        [[inputs.net]]
        [[inputs.processes]]
        [[inputs.swap]]
        [[inputs.system]]
    description: Linux
    name: Linux
---
apiVersion: influxdata.com/v2alpha1
kind: Telegraf
metadata:
    name: nostalgic-roentgen-3af001
spec:
    config: |-
        # Configuration for telegraf agent
        [agent]
          ## Default data collection interval for all inputs
          interval = "10s"
          ## Rounds collection interval to 'interval'
          ## ie, if interval="10s" then always collect on :00, :10, :20, etc.
          round_interval = true

          ## Telegraf will send metrics to outputs in batches of at most
          ## metric_batch_size metrics.
          ## This controls the size of writes that Telegraf sends to output plugins.
          metric_batch_size = 1000

          ## For failed writes, telegraf will cache metric_buffer_limit metrics for each
          ## output, and will flush this buffer on a successful write. Oldest metrics
          ## are dropped first when this buffer fills.
          ## This buffer only fills when writes fail to output plugin(s).
          metric_buffer_limit = 10000

          ## Collection jitter is used to jitter the collection by a random amount.
          ## Each plugin will sleep for a random time within jitter before collecting.
          ## This can be used to avoid many plugins querying things like sysfs at the
          ## same time, which can have a measurable effect on the system.
          collection_jitter = "0s"

          ## Default flushing interval for all outputs. Maximum flush_interval will be
          ## flush_interval + flush_jitter
          flush_interval = "10s"
          ## Jitter the flush interval by a random amount. This is primarily to avoid
          ## large write spikes for users running a large number of telegraf instances.
          ## ie, a jitter of 5s and interval 10s means flushes will happen every 10-15s
          flush_jitter = "0s"

          ## By default or when set to "0s", precision will be set to the same
          ## timestamp order as the collection interval, with the maximum being 1s.
          ##   ie, when interval = "10s", precision will be "1s"
          ##       when interval = "250ms", precision will be "1ms"
          ## Precision will NOT be used for service inputs. It is up to each individual
          ## service input to set the timestamp at the appropriate precision.
          ## Valid time units are "ns", "us" (or "µs"), "ms", "s".
          precision = ""

          ## Logging configuration:
          ## Run telegraf with debug log messages.
          debug = false
          ## Run telegraf in quiet mode (error log messages only).
          quiet = false
          ## Specify the log file name. The empty string means to log to stderr.
          logfile = ""

          ## Override default hostname, if empty use os.Hostname()
          hostname = ""
          ## If set to true, do no set the "host" tag in the telegraf agent.
          omit_hostname = false
        [[outputs.influxdb_v2]]	
          ## The URLs of the InfluxDB cluster nodes.
          ##
          ## Multiple URLs can be specified for a single cluster, only ONE of the
          ## urls will be written to each interval.
          ## urls exp: http://127.0.0.1:8086
          urls = ["https://influx.visiba.cloud"]

          ## Token for authentication.
          token = "$INFLUX_TOKEN"
          ## Organization is the name of the organization you wish to write to; must exist.
          organization = "Visiba"

          ## Destination bucket to write into.
          bucket = "telegraf"
        ###############################################################################
        #                                  INPUTS                                     #
        ###############################################################################
        # Statsd Server
        [[inputs.statsd]]
          ## Protocol, must be "tcp", "udp4", "udp6" or "udp" (default=udp)
          protocol = "udp"

          ## MaxTCPConnection - applicable when protocol is set to tcp (default=250)
          max_tcp_connections = 250

          ## Enable TCP keep alive probes (default=false)
          tcp_keep_alive = false

          ## Specifies the keep-alive period for an active network connection.
          ## Only applies to TCP sockets and will be ignored if tcp_keep_alive is false.
          ## Defaults to the OS configuration.
          # tcp_keep_alive_period = "2h"

          ## Address and port to host UDP listener on
          service_address = ":8125"

          ## The following configuration options control when telegraf clears it's cache
          ## of previous values. If set to false, then telegraf will only clear it's
          ## cache when the daemon is restarted.
          ## Reset gauges every interval (default=true)
          delete_gauges = true
          ## Reset counters every interval (default=true)
          delete_counters = true
          ## Reset sets every interval (default=true)
          delete_sets = true
          ## Reset timings & histograms every interval (default=true)
          delete_timings = true

          ## Percentiles to calculate for timing & histogram stats.
          percentiles = [50.0, 90.0, 99.0, 99.9, 99.95, 100.0]

          ## separator to use between elements of a statsd metric
          metric_separator = "_"

          ## Parses tags in the datadog statsd format
          ## http://docs.datadoghq.com/guides/dogstatsd/
          ## deprecated in 1.10; use datadog_extensions option instead
          parse_data_dog_tags = false

          ## Parses extensions to statsd in the datadog statsd format
          ## currently supports metrics and datadog tags.
          ## http://docs.datadoghq.com/guides/dogstatsd/
          datadog_extensions = true

          ## Parses distributions metric as specified in the datadog statsd format
          ## https://docs.datadoghq.com/developers/metrics/types/?tab=distribution#definition
          datadog_distributions = false

          ## Statsd data translation templates, more info can be read here:
          ## https://github.com/influxdata/telegraf/blob/master/docs/TEMPLATE_PATTERN.md
          # templates = [
          #     "cpu.* measurement*"
          # ]

          ## Number of UDP messages allowed to queue up, once filled,
          ## the statsd server will start dropping packets
          allowed_pending_messages = 10000

          ## Number of timing/histogram values to track per-measurement in the
          ## calculation of percentiles. Raising this limit increases the accuracy
          ## of percentiles but also increases the memory usage and cpu time.
          percentile_limit = 1000

          ## Maximum socket buffer size in bytes, once the buffer fills up, metrics
          ## will start dropping.  Defaults to the OS default.
          # read_buffer_size = 65535

          ## Max duration (TTL) for each metric to stay cached/reported without being updated.
          # max_ttl = "10h"
        [[inputs.win_perf_counters]]
          [[inputs.win_perf_counters.object]]
            # Processor usage, alternative to native, reports on a per core.
            ObjectName = "Processor"
            Instances = ["*"]
            Counters = [
              "% Idle Time",
              "% Interrupt Time",
              "% Privileged Time",
              "% User Time",
              "% Processor Time"
            ]
            Measurement = "win_cpu"
            # Set to true to include _Total instance when querying for all (*).
            IncludeTotal=true

          [[inputs.win_perf_counters.object]]
            # Disk times and queues
            ObjectName = "LogicalDisk"
            Instances = ["*"]
            Counters = [
              "% Idle Time",
              "% Disk Time",
              "% Disk Read Time",
              "% Disk Write Time",
              "% User Time",
              "% Free Space",
              "Current Disk Queue Length",
              "Free Megabytes",
              "Disk Read Bytes/sec",
              "Disk Write Bytes/sec"
            ]
            Measurement = "win_disk"
            # Set to true to include _Total instance when querying for all (*).
            #IncludeTotal=false

          [[inputs.win_perf_counters.object]]
            ObjectName = "System"
            Counters = [
              "Context Switches/sec",
              "System Calls/sec",
              "Processor Queue Length",
              "Threads",
              "System Up Time",
              "Processes"
            ]
            Instances = ["------"]
            Measurement = "win_system"
            # Set to true to include _Total instance when querying for all (*).
            #IncludeTotal=false

          [[inputs.win_perf_counters.object]]
            # Example query where the Instance portion must be removed to get data back,
            # such as from the Memory object.
            ObjectName = "Memory"
            Counters = [
              "Available Bytes",
              "Cache Faults/sec",
              "Demand Zero Faults/sec",
              "Page Faults/sec",
              "Pages/sec",
              "Transition Faults/sec",
              "Pool Nonpaged Bytes",
              "Pool Paged Bytes"
            ]
            # Use 6 x - to remove the Instance bit from the query.
            Instances = ["------"]
            Measurement = "win_mem"
            # Set to true to include _Total instance when querying for all (*).
            #IncludeTotal=false

          [[inputs.win_perf_counters.object]]
            # more counters for the Network Interface Object can be found at
            # https://msdn.microsoft.com/en-us/library/ms803962.aspx
            ObjectName = "Network Interface"
            Counters = [
              "Bytes Received/sec",
              "Bytes Sent/sec",
              "Packets Received/sec",
              "Packets Sent/sec"
            ]
            Instances = ["*"] # Use 6 x - to remove the Instance bit from the query.
            Measurement = "win_net"
            #IncludeTotal=false #Set to true to include _Total instance when querying for all (*).

          [[inputs.win_perf_counters.object]]
            # Process metrics
            ObjectName = "Process"
            Counters = [
              "% Processor Time",
              "Handle Count",
              "Private Bytes",
              "Thread Count",
              "Virtual Bytes",
              "Working Set"
              ]
            Instances = ["*"]
            Measurement = "win_proc"
            #IncludeTotal=false #Set to true to include _Total instance when querying for all (*).
    name: Windows - StatsD
---
apiVersion: influxdata.com/v2alpha1
kind: Telegraf
metadata:
    name: realistic-sammet-faf003
spec:
    config: |-
        # Configuration for telegraf agent
        [agent]
          ## Default data collection interval for all inputs
          interval = "10s"
          ## Rounds collection interval to 'interval'
          ## ie, if interval="10s" then always collect on :00, :10, :20, etc.
          round_interval = true

          ## Telegraf will send metrics to outputs in batches of at most
          ## metric_batch_size metrics.
          ## This controls the size of writes that Telegraf sends to output plugins.
          metric_batch_size = 1000

          ## For failed writes, telegraf will cache metric_buffer_limit metrics for each
          ## output, and will flush this buffer on a successful write. Oldest metrics
          ## are dropped first when this buffer fills.
          ## This buffer only fills when writes fail to output plugin(s).
          metric_buffer_limit = 10000

          ## Collection jitter is used to jitter the collection by a random amount.
          ## Each plugin will sleep for a random time within jitter before collecting.
          ## This can be used to avoid many plugins querying things like sysfs at the
          ## same time, which can have a measurable effect on the system.
          collection_jitter = "0s"

          ## Default flushing interval for all outputs. Maximum flush_interval will be
          ## flush_interval + flush_jitter
          flush_interval = "10s"
          ## Jitter the flush interval by a random amount. This is primarily to avoid
          ## large write spikes for users running a large number of telegraf instances.
          ## ie, a jitter of 5s and interval 10s means flushes will happen every 10-15s
          flush_jitter = "0s"

          ## By default or when set to "0s", precision will be set to the same
          ## timestamp order as the collection interval, with the maximum being 1s.
          ##   ie, when interval = "10s", precision will be "1s"
          ##       when interval = "250ms", precision will be "1ms"
          ## Precision will NOT be used for service inputs. It is up to each individual
          ## service input to set the timestamp at the appropriate precision.
          ## Valid time units are "ns", "us" (or "µs"), "ms", "s".
          precision = ""

          ## Logging configuration:
          ## Run telegraf with debug log messages.
          debug = false
          ## Run telegraf in quiet mode (error log messages only).
          quiet = false
          ## Specify the log file name. The empty string means to log to stderr.
          logfile = ""

          ## Override default hostname, if empty use os.Hostname()
          hostname = ""
          ## If set to true, do no set the "host" tag in the telegraf agent.
          omit_hostname = false
        [[outputs.influxdb_v2]]	
          ## The URLs of the InfluxDB cluster nodes.
          ##
          ## Multiple URLs can be specified for a single cluster, only ONE of the
          ## urls will be written to each interval.
          ## urls exp: http://127.0.0.1:8086
          urls = ["https://influx.visiba.cloud"]

          ## Token for authentication.
          token = "$INFLUX_TOKEN"
          ## Organization is the name of the organization you wish to write to; must exist.
          organization = "Visiba"

          ## Destination bucket to write into.
          bucket = "telegraf-dev"
        ###############################################################################
        #                                  INPUTS                                     #
        ###############################################################################
        # Statsd Server
        [[inputs.statsd]]
          ## Protocol, must be "tcp", "udp4", "udp6" or "udp" (default=udp)
          protocol = "udp"

          ## MaxTCPConnection - applicable when protocol is set to tcp (default=250)
          max_tcp_connections = 250

          ## Enable TCP keep alive probes (default=false)
          tcp_keep_alive = false

          ## Specifies the keep-alive period for an active network connection.
          ## Only applies to TCP sockets and will be ignored if tcp_keep_alive is false.
          ## Defaults to the OS configuration.
          # tcp_keep_alive_period = "2h"

          ## Address and port to host UDP listener on
          service_address = ":8125"

          ## The following configuration options control when telegraf clears it's cache
          ## of previous values. If set to false, then telegraf will only clear it's
          ## cache when the daemon is restarted.
          ## Reset gauges every interval (default=true)
          delete_gauges = true
          ## Reset counters every interval (default=true)
          delete_counters = true
          ## Reset sets every interval (default=true)
          delete_sets = true
          ## Reset timings & histograms every interval (default=true)
          delete_timings = true

          ## Percentiles to calculate for timing & histogram stats.
          percentiles = [50.0, 90.0, 99.0, 99.9, 99.95, 100.0]

          ## separator to use between elements of a statsd metric
          metric_separator = "_"

          ## Parses tags in the datadog statsd format
          ## http://docs.datadoghq.com/guides/dogstatsd/
          ## deprecated in 1.10; use datadog_extensions option instead
          parse_data_dog_tags = false

          ## Parses extensions to statsd in the datadog statsd format
          ## currently supports metrics and datadog tags.
          ## http://docs.datadoghq.com/guides/dogstatsd/
          datadog_extensions = true

          ## Parses distributions metric as specified in the datadog statsd format
          ## https://docs.datadoghq.com/developers/metrics/types/?tab=distribution#definition
          datadog_distributions = false

          ## Statsd data translation templates, more info can be read here:
          ## https://github.com/influxdata/telegraf/blob/master/docs/TEMPLATE_PATTERN.md
          # templates = [
          #     "cpu.* measurement*"
          # ]

          ## Number of UDP messages allowed to queue up, once filled,
          ## the statsd server will start dropping packets
          allowed_pending_messages = 10000

          ## Number of timing/histogram values to track per-measurement in the
          ## calculation of percentiles. Raising this limit increases the accuracy
          ## of percentiles but also increases the memory usage and cpu time.
          percentile_limit = 1000

          ## Maximum socket buffer size in bytes, once the buffer fills up, metrics
          ## will start dropping.  Defaults to the OS default.
          # read_buffer_size = 65535

          ## Max duration (TTL) for each metric to stay cached/reported without being updated.
          # max_ttl = "10h"
        [[inputs.win_perf_counters]]
          [[inputs.win_perf_counters.object]]
            # Processor usage, alternative to native, reports on a per core.
            ObjectName = "Processor"
            Instances = ["*"]
            Counters = [
              "% Idle Time",
              "% Interrupt Time",
              "% Privileged Time",
              "% User Time",
              "% Processor Time"
            ]
            Measurement = "win_cpu"
            # Set to true to include _Total instance when querying for all (*).
            IncludeTotal=true

          [[inputs.win_perf_counters.object]]
            # Disk times and queues
            ObjectName = "LogicalDisk"
            Instances = ["*"]
            Counters = [
              "% Idle Time",
              "% Disk Time",
              "% Disk Read Time",
              "% Disk Write Time",
              "% User Time",
              "% Free Space",
              "Current Disk Queue Length",
              "Free Megabytes",
              "Disk Read Bytes/sec",
              "Disk Write Bytes/sec"
            ]
            Measurement = "win_disk"
            # Set to true to include _Total instance when querying for all (*).
            #IncludeTotal=false

          [[inputs.win_perf_counters.object]]
            ObjectName = "System"
            Counters = [
              "Context Switches/sec",
              "System Calls/sec",
              "Processor Queue Length",
              "Threads",
              "System Up Time",
              "Processes"
            ]
            Instances = ["------"]
            Measurement = "win_system"
            # Set to true to include _Total instance when querying for all (*).
            #IncludeTotal=false

          [[inputs.win_perf_counters.object]]
            # Example query where the Instance portion must be removed to get data back,
            # such as from the Memory object.
            ObjectName = "Memory"
            Counters = [
              "Available Bytes",
              "Cache Faults/sec",
              "Demand Zero Faults/sec",
              "Page Faults/sec",
              "Pages/sec",
              "Transition Faults/sec",
              "Pool Nonpaged Bytes",
              "Pool Paged Bytes"
            ]
            # Use 6 x - to remove the Instance bit from the query.
            Instances = ["------"]
            Measurement = "win_mem"
            # Set to true to include _Total instance when querying for all (*).
            #IncludeTotal=false

          [[inputs.win_perf_counters.object]]
            # more counters for the Network Interface Object can be found at
            # https://msdn.microsoft.com/en-us/library/ms803962.aspx
            ObjectName = "Network Interface"
            Counters = [
              "Bytes Received/sec",
              "Bytes Sent/sec",
              "Packets Received/sec",
              "Packets Sent/sec"
            ]
            Instances = ["*"] # Use 6 x - to remove the Instance bit from the query.
            Measurement = "win_net"
            #IncludeTotal=false #Set to true to include _Total instance when querying for all (*).

          [[inputs.win_perf_counters.object]]
            # Process metrics
            ObjectName = "Process"
            Counters = [
              "% Processor Time",
              "Handle Count",
              "Private Bytes",
              "Thread Count",
              "Virtual Bytes",
              "Working Set"
              ]
            Instances = ["*"]
            Measurement = "win_proc"
            #IncludeTotal=false #Set to true to include _Total instance when querying for all (*).
    name: Windows - StatsD Dev
---
apiVersion: influxdata.com/v2alpha1
kind: Telegraf
metadata:
    name: spectacular-joliot-3af003
spec:
    config: |
        # Configuration for telegraf agent
        [agent]
          ## Default data collection interval for all inputs
          interval = "10s"
          ## Rounds collection interval to 'interval'
          ## ie, if interval="10s" then always collect on :00, :10, :20, etc.
          round_interval = true

          ## Telegraf will send metrics to outputs in batches of at most
          ## metric_batch_size metrics.
          ## This controls the size of writes that Telegraf sends to output plugins.
          metric_batch_size = 1000

          ## For failed writes, telegraf will cache metric_buffer_limit metrics for each
          ## output, and will flush this buffer on a successful write. Oldest metrics
          ## are dropped first when this buffer fills.
          ## This buffer only fills when writes fail to output plugin(s).
          metric_buffer_limit = 10000

          ## Collection jitter is used to jitter the collection by a random amount.
          ## Each plugin will sleep for a random time within jitter before collecting.
          ## This can be used to avoid many plugins querying things like sysfs at the
          ## same time, which can have a measurable effect on the system.
          collection_jitter = "0s"

          ## Default flushing interval for all outputs. Maximum flush_interval will be
          ## flush_interval + flush_jitter
          flush_interval = "10s"
          ## Jitter the flush interval by a random amount. This is primarily to avoid
          ## large write spikes for users running a large number of telegraf instances.
          ## ie, a jitter of 5s and interval 10s means flushes will happen every 10-15s
          flush_jitter = "0s"

          ## By default or when set to "0s", precision will be set to the same
          ## timestamp order as the collection interval, with the maximum being 1s.
          ##   ie, when interval = "10s", precision will be "1s"
          ##       when interval = "250ms", precision will be "1ms"
          ## Precision will NOT be used for service inputs. It is up to each individual
          ## service input to set the timestamp at the appropriate precision.
          ## Valid time units are "ns", "us" (or "µs"), "ms", "s".
          precision = ""

          ## Logging configuration:
          ## Run telegraf with debug log messages.
          debug = false
          ## Run telegraf in quiet mode (error log messages only).
          quiet = false
          ## Specify the log file name. The empty string means to log to stderr.
          logfile = ""

          ## Override default hostname, if empty use os.Hostname()
          hostname = ""
          ## If set to true, do no set the "host" tag in the telegraf agent.
          omit_hostname = false
        [[outputs.influxdb_v2]]	
          ## The URLs of the InfluxDB cluster nodes.
          ##
          ## Multiple URLs can be specified for a single cluster, only ONE of the
          ## urls will be written to each interval.
          ## urls exp: http://127.0.0.1:8086
          urls = ["https://influx.visiba.cloud"]

          ## Token for authentication.
          token = "$INFLUX_TOKEN"

          ## Organization is the name of the organization you wish to write to; must exist.
          organization = "Visiba"

          ## Destination bucket to write into.
          bucket = "telegraf-kubernetes"
    name: Telegraf Kubernetes
---
apiVersion: influxdata.com/v2alpha1
kind: Telegraf
metadata:
    name: wonderful-neumann-7af001
spec:
    config: |
        [[outputs.influxdb_v2]]
          ## The URLs of the InfluxDB cluster nodes.
          ##
          ## Multiple URLs can be specified for a single cluster, only ONE of the
          ## urls will be written to each interval.
          ## urls exp: http://127.0.0.1:9999
          urls = ["$INFLUX_HOST"]

          ## Token for authentication.
          token = "$INFLUX_TOKEN"

          ## Organization is the name of the organization you wish to write to; must exist.
          organization = "$INFLUX_ORG"

          ## Destination bucket to write into.
          bucket = "haproxy"

          [agent]
          interval = "1m"

        # Read metrics of HAProxy, via socket or HTTP stats page
        [[inputs.haproxy]]
          ## An array of address to gather stats about. Specify an ip on hostname
          ## with optional port. ie localhost, 10.10.3.33:1936, etc.
          ## Make sure you specify the complete path to the stats endpoint
          ## including the protocol, ie http://localhost:10000/haproxy?stats

          ## Credentials for basic HTTP authentication
          # username = "admin"
          # password = "admin"

          ## If no servers are specified, then default to 127.0.0.1:1936/haproxy?stats
          # servers = ["http://localhost:10000/stats"]
          servers = ["$haproxy_stats"]

          ## You can also use local socket with standard wildcard globbing.
          ## Server address not starting with 'http' will be treated as a possible
          ## socket, so both examples below are valid.
          # servers = ["socket:/run/haproxy/admin.sock", "/run/haproxy/*.sock"]

          ## By default, some of the fields are renamed from what haproxy calls them.
          ## Setting this option to true results in the plugin keeping the original
          ## field names.
          # keep_field_names = false

          ## Optional TLS Config
          # tls_ca = "/etc/telegraf/ca.pem"
          # tls_cert = "/etc/telegraf/cert.pem"
          # tls_key = "/etc/telegraf/key.pem"
          ## Use TLS but skip chain & host verification
          # insecure_skip_verify = false

        # Read metrics about system load & uptime
        [[inputs.system]]
          # no configuration

        [[inputs.cpu]]
          ## Whether to report per-cpu stats or not
          percpu = true
          ## Whether to report total system cpu stats or not
          totalcpu = true
          ## If true, collect raw CPU time metrics.
          collect_cpu_time = false
          ## If true, compute and report the sum of all non-idle CPU states.
          report_active = false

        # Read metrics about memory usage
        [[inputs.mem]]
          # no configuration
    name: haproxy-config
